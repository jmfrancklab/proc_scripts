
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/generate_integrals.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_generate_integrals.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_generate_integrals.py:


Convert 2D to Integrals with Errors
===================================

Take a 2D dataset and convert it to a table of integrals with errors, utilizing
all the bells and whistles (frequency and time selection, alignment, etc.)

Demonstrate on a fake dataset of an inversion recovery with multiple repeats (φ
× t2 × vd × repeats) w/ normally distributed random noise, and with fluctuating field
(normally distributed field variation).

.. GENERATED FROM PYTHON SOURCE LINES 12-91


.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "/home/jmfranck/git_repos/proc_scripts/examples/generate_integrals.py", line 82, in <module>
        data_int, data = generate_integrals(
                         ^^^^^^^^^^^^^^^^^^^
      File "/home/jmfranck/git_repos/proc_scripts/pyspecProcScripts/generate_integrals.py", line 99, in generate_integrals
        mysgn = determine_sign(select_pathway(s_mean, signal_pathway))  # must be
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    TypeError: determine_sign() missing 1 required positional argument: 'signal_freq_range'






|

.. code-block:: Python

    from pylab import *
    from pyspecdata import *
    from pyspecProcScripts import *
    from numpy.random import seed
    import sympy as s
    from collections import OrderedDict

    init_logging(level="debug")

    seed(2021)
    rcParams["image.aspect"] = "auto"  # needed for sphinx gallery
    # sphinx_gallery_thumbnail_number = 3

    fl = fl_mod()
    t2, td, vd, power, ph1, ph2 = s.symbols("t2 td vd power ph1 ph2")
    echo_time = 10e-3
    with figlist_var() as fl:
        for (
            expression,
            variable_defs,
            signal_pathway,
            indirect,
            clock_correction,
            label,
            f_range,
        ) in [
            (
                (
                    23
                    * (1 - 2 * s.exp(-vd / 0.2))
                    * s.exp(+1j * 2 * s.pi * 100 * (t2) - abs(t2) * 50 * s.pi)
                ),
                [
                    ("vd", nddata(r_[0:1:40j], "vd")),
                    ("ph1", nddata(r_[0:4] / 4.0, "ph1")),
                    ("ph2", nddata(r_[0, 2] / 4.0, "ph2")),
                    ("t2", nddata(r_[0:0.2:256j] - echo_time, "t2")),
                ],
                {"ph1": 0, "ph2": 1},
                "vd",
                True,
                "IR",
                (-400, 400),
            ),
            (
                (
                    23
                    * (1 - (32 * power / (0.25 + power)) * 150e-6 * 659.33)
                    * s.exp(+1j * 2 * s.pi * 100 * t2 - abs(t2) * 50 * s.pi)
                ),
                [
                    ("power", nddata(r_[0:4:25j], "power")),
                    ("ph1", nddata(r_[0:4] / 4.0, "ph1")),
                    ("t2", nddata(r_[0:0.2:256j] - echo_time, "t2")),
                ],
                {"ph1": 1},
                "power",
                False,
                "Enhancement",
                (-200, 600),
            ),
        ]:
            fl.basename = "(%s)" % label
            data = fake_data(
                expression, OrderedDict(variable_defs), signal_pathway
            )
            data.ft("t2")
            # {{{ make data unitary again
            data /= sqrt(ndshape(data)["t2"]) * data.get_ft_prop("t2", "dt")
            # }}}
            data_int, data = generate_integrals(
                s=data,
                signal_pathway=signal_pathway,
                searchstr=label,
                f_range=f_range,
                indirect=indirect,
                clock_correction=clock_correction,
                fl=fl,
            )


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.303 seconds)


.. _sphx_glr_download_auto_examples_generate_integrals.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: generate_integrals.ipynb <generate_integrals.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: generate_integrals.py <generate_integrals.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
