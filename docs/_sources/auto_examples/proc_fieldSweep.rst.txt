
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\proc_fieldSweep.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_proc_fieldSweep.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_proc_fieldSweep.py:

Check NMR/ESR resonance ratio using a field sweep
====================================================

Analyzes field sweep data.  Determines the resonance frequency from the carrier
frequency and the offset of the signal, converts to MHz, then divide by the
Bridge 12 μw frequency stored in the file to get the resonance ratio of MHz/GHz

.. GENERATED FROM PYTHON SOURCE LINES 8-115



.. image-sg:: /auto_examples/images/sphx_glr_proc_fieldSweep_001.png
   :alt: Raw data Frequency Domain, Field Slicing, Field Sweep ppt
   :srcset: /auto_examples/images/sphx_glr_proc_fieldSweep_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\jmfranck\pyspecdata.0.log appears to be locked or otherwise inaccessible: I'm going to explore other options for fileno
    ----------  logging output to C:\Users\jmfranck\pyspecdata.9.log  ----------
    --> load_data.py(664):root  proc_field_sweep_v1 2023-05-13 16:28:49,121
    INFO: WARNING WARNING, you are using the wrong version of the field sweep code -- should be chunked when data is saved, not on loading!
    --> load_data.py(667):root  proc_field_sweep_v1 2023-05-13 16:28:49,122
    INFO: loading preprocessing for fieldsweep
    C:\ProgramData\Anaconda3\lib\site-packages\matplotlib\cbook\__init__.py:1335: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    c:\users\jmfranck\git_repos\pyspecdata\pyspecdata\core.py:1959: UserWarning: linestyle is redundantly defined by the 'linestyle' keyword argument and the fmt string "o-" (-> linestyle='-'). The keyword argument will take precedence.
      retval = myplotfunc(*plotargs,**kwargs)
    c:\users\jmfranck\git_repos\pyspecdata\pyspecdata\core.py:1959: UserWarning: marker is redundantly defined by the 'marker' keyword argument and the fmt string "o-" (-> marker='o'). The keyword argument will take precedence.
      retval = myplotfunc(*plotargs,**kwargs)
    --> proc_fieldSweep.py(111):pyspecdata.core             <module> 2023-05-13 16:28:50,884
    INFO: ESR frequency is 9.820929
    --> proc_fieldSweep.py(112):pyspecdata.core             <module> 2023-05-13 16:28:50,885
    INFO: MHz/GHz value at peak/dip appears to be: (1.5166088567255+6.791080188117843e-05j)
    --> legend.py(1330):matplotlib.legend   _parse_legend_args 2023-05-13 16:28:50,888
    WARNING: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
    --> legend.py(1330):matplotlib.legend   _parse_legend_args 2023-05-13 16:28:50,889
    WARNING: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.






|

.. code-block:: default


    from pylab import *
    from pyspecdata import *
    from pyspecProcScripts import *
    from pyspecProcScripts import lookup_table
    from sympy import symbols
    init_logging(level='debug')
    fl = figlist_var()
    rcParams["image.aspect"] = "auto" # needed for sphinx gallery

    #sphinx_gallery_thumbnail_number = 1

    signal_pathway = {'ph1':1}
    for thisfile,exp_type,nodename,postproc,label_str,freq_slice in [
            ('220217_5mM_TEMPOL_field_dep',
                'ODNP_NMR_comp/field_dependent',
                'Field_sweep',
                'field_sweep_v1',# in newer version files, we should be setting
                #                  postproc_type as a top-level attribute of the
                #                  nddata, and this should not be necessary
                'TEMPOL field sweep',
                (-250,250)),
            ]:
        s = find_file(thisfile,exp_type=exp_type,expno=nodename,
                postproc=postproc,lookup=lookup_table)
        #{{{Obtain ESR frequency and chunk/reorder dimensions
        nu_B12_GHz = (s.get_prop('acq_params')['mw_freqs'][0])/1e9
        #}}}
        #{{{DC offset correction
        s.ift('t2')
        s.ift('ph1')
        t2_max = s.getaxis('t2')[-1]
        rx_offset_corr = s['t2':(t2_max*0.75,None)]
        rx_offset_corr = rx_offset_corr.mean(['t2'])
        s -= rx_offset_corr
        s.ft(['ph1'])
        s.ft('t2')
        #}}}
        # {{{ set up figure and plot raw data
        fig, ax_list = subplots(1, 4, figsize=(10,3))
        fl.next('Field Sweep Processing',fig=fig)
        fl.image(s,ax = ax_list[0])
        ax_list[0].set_title('Raw data\nFrequency Domain')
        # }}}
        #{{{frequency filtering and phase correct
        s = s['t2':(-1e3,1e3)]
        s.ift('t2')
        best_shift = hermitian_function_test(select_pathway(s,signal_pathway))
        s.setaxis('t2', lambda x: x-best_shift).register_axis({'t2':0})
        s = s['t2':(0,None)]
        s['t2',0] *= 0.5
        s.ft('t2')
        s = select_pathway(s,signal_pathway)
        s /= zeroth_order_ph(s.C.mean('t2'))
        nu_NMR=[]
        assert set(s.getaxis('indirect').dtype.names) == {'Field', 'carrierFreq'}, "'indirect' axis should be a structured array that stores the carrier frequency and the field"
        # {{{ the following works fine for all the cases that we've tested, and so
        # there's no need to change it.  But, after resolving everything, realized
        # that the best way to deal with this would be to run a correlation on all
        # the scans to determine the relative offsets, which would give both the
        # relative offsets and the frequency shifts needed to align the signals, at
        # the end.
        all_offsets = zeros(len(s.getaxis('indirect')))
        for z in range(len(s.getaxis('indirect'))):
            fl.plot(s['indirect',z],ax=ax_list[1])
            if z == 0:
                ax_list[1].axvline(color='k',x = freq_slice[0])
                ax_list[1].axvline(color='k',x=freq_slice[-1])
            offset = s['indirect',z].C.mean('nScans').argmax('t2').item()
            all_offsets[z] = offset
            carrier_freq_MHz = s.getaxis('indirect')[z]['carrierFreq']
            field = s.getaxis('indirect')[z]['Field']
            nu_rf = carrier_freq_MHz - offset/1e6 # because in order to make my
            #                                       offset more negative, I
            #                                       increase my field, or decrease
            #                                       my carrier -- in other words
            #                                       the frequency axis for our FID
            #                                       is the negative of (ν_RF-ν_carrier)
            nu_NMR.append(nu_rf) 
        ax_list[1].set_title('Field Slicing')
        s.ift('t2')
        s *= exp(-1j*2*pi*nddata(all_offsets, [-1], ['indirect'])*s.fromaxis('t2'))
        s.ft('t2')
        # }}}
        fl.plot(s.C.mean('nScans'), ax = ax_list[2])
        s = s['t2':freq_slice].mean('nScans').integrate('t2')
        #}}}
        #{{{convert x axis to ppt = v_NMR/v_ESR
        ppt = nu_NMR / nu_B12_GHz 
        s.setaxis('indirect',ppt)
        s.set_units('indirect','MHz/GHz')
        s.rename('indirect','resonance ratio')
        #}}}
        #{{{Fitting
        fl.plot(s,'o-',ax=ax_list[3])
        ax_list[3].set_title('Field Sweep ppt')
        fitting = s.polyfit('resonance ratio',order=2)
        field_fine = nddata(r_[s.getaxis('resonance ratio')[0]:s.getaxis('resonance ratio')[-1]:100j],'resonance ratio')
        polyline = fl.plot(field_fine.eval_poly(fitting,'resonance ratio'),label='fit',ax=ax_list[3])
        fig.tight_layout(rect=[0, 0.03, 1, 0.95])
        _, B, A = fitting
        center = -B/2/A
        #}}}
        logger.info(strm("ESR frequency is %f"%(nu_B12_GHz)))
        logger.info(strm("MHz/GHz value at peak/dip appears to be:",center))
        ax_list[3].axvline(x=center, color=polyline[0].get_color(), ls=':')
    fl.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.055 seconds)


.. _sphx_glr_download_auto_examples_proc_fieldSweep.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: proc_fieldSweep.py <proc_fieldSweep.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: proc_fieldSweep.ipynb <proc_fieldSweep.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
